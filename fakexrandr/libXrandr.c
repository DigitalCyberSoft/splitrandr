/*
	FakeXRandR
	Copyright (c) 2015, Phillip Berndt

	This is a replacement library for libXrandr.so and, optionally,
	libXinerama.so. It replaces configurable outputs with multiple
	sub-outputs.
*/

#include <unistd.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <X11/extensions/Xrandr.h>
#include <X11/extensions/Xinerama.h>
#include <X11/Xlib.h>
#include <X11/Xlibint.h>
#include <xcb/xcb.h>
#include <xcb/randr.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>
#include <string.h>


/*
	The management script uses this symbol to identify the fake libXrandr version
*/
int _is_fake_xrandr = 1;

/*
	Config format version. Bumped when the binary config layout changes.
	The Python side reads this via ctypes to detect .so / config mismatches.
*/
int _fakexrandr_config_version = 1;

/*
	We use this XID modifier to flag outputs and CRTCs as
	fake by adding a counter in the first few bits:
	 · xid & ~XID_SPLIT_MASK is the xid of the original output
	 · xid >> XID_SPLIT_SHIFT is the counter identifying a virtual, split screen

	On the choice: A typical XID is of the form
	 client_id | (xid_mask & arbitrary value),
	according to the documentation of the X-Resource extension. On my system,
	 xid_mask = 0x001FFFFF
	and client_id == 0 for all reources mentioned in the RandR protocol.
	All we need to do is to choose XID_SPLIT_MASK such that
	XID_SPLIT_MASK & xid_mask == 0.
*/
#define XID_SPLIT_SHIFT 21
#define XID_SPLIT_MASK  0x7FE00000

/*
	Generated by ./configure:
*/
#include "config.h"

/*
	The skeleton file is created by ./make_skeleton.py

	It contains wrappers around all Xrandr functions which are not
	explicitly defined in this C file, replacing all references to
	crtcs and outputs which are fake with the real ones.
*/
#include "skeleton.h"

/*
	We use an augmented version of the screen resources to store all our
	information: We preallocate all XRROutputInfo and XRRCrtcInfo structures
	for the fake screens upon a request for screen resources and only return
	pointers in the functions that return them.
*/
struct FakeInfo {
	XID xid;
	XID parent_xid;
	void *info;
	struct FakeInfo *next;
};

struct FakeScreenResources {
	// This is crafted to look like a XRRScreenResources to an unaware user
	XRRScreenResources res;

	// This points to the original screen resources. We don't free them to
	// be able to use the original strings/lists without having to copy them.
	XRRScreenResources *parent_res;

	// These lists point to the fake OutputInfo/CrtcInfo/Mode structures
	struct FakeInfo *fake_crtcs;
	struct FakeInfo *fake_outputs;
	struct FakeInfo *fake_modes;
};

/*
	Configuration management

	The configuration file format is documented in the management script. These
	functions load the configuration file and fill the FakeInfo lists with
	information on the fake outputs.
*/
static char *config_file;
static int config_file_fd;
static size_t config_file_size;
/* Config data starts at offset 8 (after "FXRD" + uint32 version header) */
#define CONFIG_DATA_OFFSET 8

static char *_config_foreach_split(char *config, unsigned int *n, unsigned int x, unsigned int y, unsigned int width, unsigned int height, unsigned int border, XRRScreenResources *resources, RROutput output, XRROutputInfo *output_info,
		XRRCrtcInfo *crtc_info, struct FakeInfo ***fake_crtcs, struct FakeInfo ***fake_outputs, struct FakeInfo ***fake_modes) {

	if(config[0] != 'N' && config[0] != 'H' && config[0] != 'V') {
		// Corrupt or incompatible config — bail out silently
		return NULL;
	}

	if(config[0] == 'N') {
		// Border is stored in config but only used by setmonitor commands
		// (for mouse dead zones). CRTCs use full dimensions — no visible gap.
		(void)border;
		// Define a new output info
		**fake_outputs = Xmalloc(sizeof(struct FakeInfo) + sizeof(XRROutputInfo) + output_info->nameLen + sizeof("~NNN ") + sizeof(RRCrtc) + sizeof(RROutput) * output_info->nclone + (1 + output_info->nmode) * sizeof(RRMode));
		(**fake_outputs)->xid = (output & ~XID_SPLIT_MASK) | ((++(*n)) << XID_SPLIT_SHIFT);
		(**fake_outputs)->parent_xid = output;
		XRROutputInfo *fake_info = (**fake_outputs)->info = (void*)**fake_outputs + sizeof(struct FakeInfo);
		fake_info->timestamp = output_info->timestamp;
		fake_info->name = (void*)fake_info + sizeof(XRROutputInfo);
		fake_info->nameLen = sprintf(fake_info->name, "%s~%d", output_info->name, (*n));
		fake_info->mm_width = output_info->mm_width * width / crtc_info->width;
		fake_info->mm_height = output_info->mm_height * height / crtc_info->height;
		fake_info->connection = output_info->connection;
		fake_info->subpixel_order = output_info->subpixel_order;
		fake_info->ncrtc = 1;
		fake_info->crtcs = (void*)fake_info->name + output_info->nameLen + sizeof("~NNN ");
		fake_info->nclone = output_info->nclone;
		fake_info->clones = (void*)fake_info->crtcs + sizeof(RRCrtc);
		int i;
		for(i=0; i<fake_info->nclone; i++) {
			fake_info->clones[i] = (output_info->clones[i] & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);
		}
		fake_info->nmode = 1 + output_info->nmode;
		fake_info->npreferred = 0;
		fake_info->modes = (void*)fake_info->clones + fake_info->nclone * sizeof(RROutput);
		fake_info->crtc = *fake_info->crtcs = *fake_info->modes = (output_info->crtc & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);
		memcpy(fake_info->modes + 1, output_info->modes, sizeof(RRMode) * output_info->nmode);

		*fake_outputs = &(**fake_outputs)->next;
		**fake_outputs = NULL;

		// Define a new CRTC info
		**fake_crtcs = Xmalloc(sizeof(struct FakeInfo) + sizeof(XRRCrtcInfo) + sizeof(RROutput));
		(**fake_crtcs)->xid = (output_info->crtc & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);
		(**fake_crtcs)->parent_xid = output_info->crtc;
		XRRCrtcInfo *fake_crtc_info = (**fake_crtcs)->info = ((void*)**fake_crtcs) + sizeof(struct FakeInfo);
		*fake_crtc_info = *crtc_info;
		fake_crtc_info->x = crtc_info->x + x;
		fake_crtc_info->y = crtc_info->y + y;
		fake_crtc_info->width = width;
		fake_crtc_info->height = height;
		fake_crtc_info->mode = *(fake_info->modes);
		fake_crtc_info->noutput = 1;
		fake_crtc_info->outputs = (void*)fake_crtc_info + sizeof(XRRCrtcInfo);
		*(fake_crtc_info->outputs) = (output & ~XID_SPLIT_MASK) | (((*n)) << XID_SPLIT_SHIFT);
		fake_crtc_info->npossible = 1;
		fake_crtc_info->possible = fake_crtc_info->outputs;

		*fake_crtcs = &(**fake_crtcs)->next;
		**fake_crtcs = NULL;

		// Define a new fake mode
		**fake_modes = Xcalloc(1, sizeof(struct FakeInfo) + sizeof(XRRModeInfo) + sizeof("XXXXxXXXX"));
		(**fake_modes)->xid = (output_info->crtc & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);
		(**fake_modes)->parent_xid = 0;
		XRRModeInfo *fake_mode_info = (**fake_modes)->info = (void*)**fake_modes + sizeof(struct FakeInfo);
		for(i=0; i<resources->nmode; i++) {
			if(resources->modes[i].id == crtc_info->mode) {
				*fake_mode_info = resources->modes[i];
				break;
			}
		}
		fake_mode_info->id = (**fake_modes)->xid;
		fake_mode_info->width = width;
		fake_mode_info->height = height;
		fake_mode_info->name = (void*)fake_mode_info + sizeof(XRRModeInfo);
		fake_mode_info->nameLength = sprintf(fake_mode_info->name, "%dx%d", width, height);

		*fake_modes = &(**fake_modes)->next;
		**fake_modes = NULL;

		return config + 1;
	}
	unsigned int split_pos = *(unsigned int *)&config[1];
	if(config[0] == 'H') {
		// PR #27: treat split_pos == 0 as "divide equally"
		if(split_pos == 0) split_pos = height / 2;
		config = _config_foreach_split(config + 1 + 4, n, x, y, width, split_pos, border, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);
		if(!config) return NULL;
		return _config_foreach_split(config, n, x, y + split_pos, width, height - split_pos, border, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);
	}
	else {
		// PR #27: treat split_pos == 0 as "divide equally"
		if(split_pos == 0) split_pos = width / 2;
		config = _config_foreach_split(config + 1 + 4, n, x, y, split_pos, height, border, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);
		if(!config) return NULL;
		return _config_foreach_split(config, n, x + split_pos, y, width - split_pos, height, border, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);
	}
}

static int config_handle_output(Display *dpy, XRRScreenResources *resources, RROutput output, char *target_edid, const char *target_name, struct FakeInfo ***fake_crtcs, struct FakeInfo ***fake_outputs, struct FakeInfo ***fake_modes) {
	char *config;
	for(config = config_file + CONFIG_DATA_OFFSET; (int)(config - config_file) <= (int)config_file_size; ) {
		// Walk through the configuration file and search by name or EDID
		unsigned int size = *(unsigned int *)config;
		char *name = &config[4];
		char *edid = &config[4 + 128];
		unsigned int width = *(unsigned int *)&config[4 + 128 + 768];
		unsigned int height = *(unsigned int *)&config[4 + 128 + 768 + 4];

		// Match by output name first, fall back to EDID.
		// When fakexrandr is active, virtual outputs have no EDID,
		// so the config may be written with an empty EDID field.
		int name_match = (target_name && strncmp(name, target_name, 128) == 0);
		int edid_match = (strncmp(edid, target_edid, 768) == 0);

		if(name_match || edid_match) {
			XRROutputInfo *output_info = _XRRGetOutputInfo(dpy, resources, output);
			if(!output_info || output_info->crtc == 0) {
				return 0;
			}

			XRRCrtcInfo *output_crtc = _XRRGetCrtcInfo(dpy, resources, output_info->crtc);
			if(!output_crtc) {
				return 0;
			}

			// PR #27: treat width/height 0 as "use current CRTC dimensions"
			unsigned int effective_width = width ? width : output_crtc->width;
			unsigned int effective_height = height ? height : output_crtc->height;

			if(output_crtc->width == effective_width && output_crtc->height == effective_height) {
				unsigned int border = *(unsigned int *)&config[4 + 128 + 768 + 4 + 4 + 4];
				char *tree_start = config + 4 + 128 + 768 + 4 + 4 + 4 + 4;

				// If it is found and the size matches, add fake outputs/crtcs to the list
				unsigned n = 0;
				_config_foreach_split(tree_start, &n, 0, 0, effective_width, effective_height, border, resources, output, output_info, output_crtc, fake_crtcs, fake_outputs, fake_modes);
				return 1;
			}
		}

		config += 4 + size;
	}

	return 0;
}


static void close_configuration() {
	munmap(config_file, config_file_size);
	close(config_file_fd);
	config_file = NULL;
}

static int open_configuration() {
	// Load the configuration from ${XDG_CONFIG_HOME:-$HOME/.config}/fakexrandr.bin
	if(config_file) {
		close_configuration();
	}

	char *config_dir = getenv("XDG_CONFIG_HOME");
	if(!config_dir) {
		char *home_dir = getenv("HOME");
		if(!home_dir) {
			return 1;
		}
		config_dir = alloca(512);
		if(snprintf(config_dir, 512, "%s/.config", home_dir) >= 512) {
			return 1;
		}
	}

	char config_file_path[512];
	if(snprintf(config_file_path, 512, "%s/fakexrandr.bin", config_dir) >= 512) {
		return 1;
	}
	if(access(config_file_path, R_OK)) {
		return 1;
	}

	config_file_fd = open(config_file_path, O_RDONLY);
	if(config_file_fd < 0) {
		perror("fakexrandr/open()");
		return 1;
	}
	struct stat config_stat;
	fstat(config_file_fd, &config_stat);
	config_file_size = config_stat.st_size;
	config_file = mmap(NULL, config_file_size, PROT_READ, MAP_SHARED, config_file_fd, 0);
	if(config_file == MAP_FAILED) {
		perror("fakexrandr/mmap()");
		config_file = NULL;
		close(config_file_fd);
		return 1;
	}

	/* Require FXRD magic header */
	if(config_file_size < 8 || memcmp(config_file, "FXRD", 4) != 0) {
		fprintf(stderr, "fakexrandr: config missing FXRD header, ignoring\n");
		close_configuration();
		return 1;
	}
	unsigned int file_version = *(unsigned int *)(config_file + 4);
	if(file_version > (unsigned int)_fakexrandr_config_version) {
		fprintf(stderr, "fakexrandr: config version %u > supported %d, ignoring\n",
			file_version, _fakexrandr_config_version);
		close_configuration();
		return 1;
	}

	return 0;
}

/*
	Helper function to return a hex-coded EDID string for a given output

	edid must point to a sufficiently large (768 bytes) buffer.
*/
static int get_output_edid(Display *dpy, RROutput output, char *edid) {
	Atom actual_type;
	int actual_format;
	unsigned long nitems = 0;
	unsigned long bytes_after;
	unsigned char *prop = NULL;

	// PR #27: initialize EDID buffer to empty string
	memset(edid, 0, 768);

	// PR #27: handle missing EDID atom gracefully
	Atom edid_atom = XInternAtom(dpy, "EDID", 1);
	if(edid_atom == None) {
		return 0;
	}

	_XRRGetOutputProperty(dpy, output, edid_atom, 0, 384,
			0, 0, 0, &actual_type, &actual_format, &nitems, &bytes_after, &prop);

	if(nitems > 0 && prop) {
		unsigned i;
		for(i=0; i<nitems; i++) {
			edid[2*i] = ((prop[i] >> 4) & 0xf) + '0';
			if(edid[2*i] > '9') {
				edid[2*i] += 'a' - '0' - 10;
			}

			edid[2*i+1] = (prop[i] & 0xf) + '0';
			if(edid[2*i+1] > '9') {
				edid[2*i+1] += 'a' - '0' - 10;
			}
		}
		edid[nitems*2] = 0;

		XFree(prop);
	}

	return nitems * 2;
}

/*
	Helper functions for the FakeInfo list structure
*/
static int list_length(struct FakeInfo *list) {
	int i = 0;
	while(list) {
		list = list->next;
		i += 1;
	}
	return i;
}

static void free_list(struct FakeInfo *list) {
	while(list) {
		struct FakeInfo *last = list;
		list = list->next;
		Xfree(last);
	}
}

static struct FakeInfo *xid_in_list(struct FakeInfo *list, XID xid) {
	while(list) {
		if(list->xid == xid || list->parent_xid == xid) return list;
		list = list->next;
	}
	return NULL;
}

/*
	The following function augments the original XRRScreenResources with the
	fake outputs
*/
static struct FakeScreenResources *augment_resources(Display *dpy, XRRScreenResources *res) {
	struct FakeInfo *outputs = NULL;
	struct FakeInfo *crtcs = NULL;
	struct FakeInfo *modes = NULL;

	struct FakeInfo **outputs_end = &outputs;
	struct FakeInfo **crtcs_end = &crtcs;
	struct FakeInfo **modes_end = &modes;

	// Fill the FakeInfo structures
	if(open_configuration()) {
		struct FakeScreenResources *retval = Xcalloc(1, sizeof(struct FakeScreenResources));
		retval->res = *res;
		retval->parent_res = res;
		return retval;
	}

	int i;
	for(i=0; i<res->noutput; i++) {
		char output_edid[768];
		get_output_edid(dpy, res->outputs[i], output_edid);
		XRROutputInfo *oi = _XRRGetOutputInfo(dpy, res, res->outputs[i]);
		const char *output_name = oi ? oi->name : NULL;
		config_handle_output(dpy, res, res->outputs[i], output_edid, output_name, &crtcs_end, &outputs_end, &modes_end);
		if(oi) _XRRFreeOutputInfo(oi);
	}

	int ncrtc = res->ncrtc + list_length(crtcs);
	int noutput = res->noutput + list_length(outputs);
	int nmodes = res->nmode + list_length(modes);

	// Create a new XRRScreenResources with the fake information in place
	struct FakeScreenResources *retval = Xmalloc(sizeof(struct FakeScreenResources) + ncrtc * sizeof(RRCrtc) + noutput * sizeof(RROutput) + nmodes * sizeof(XRRModeInfo));

	retval->res = *res;
	retval->parent_res = res;
	retval->fake_crtcs = crtcs;
	retval->fake_outputs = outputs;

	// We copy all the original CRTCs and add our fake ones
	retval->res.ncrtc = ncrtc;
	retval->res.crtcs = (void*)retval + sizeof(struct FakeScreenResources);
	memcpy(retval->res.crtcs, res->crtcs, sizeof(RRCrtc) * res->ncrtc);
	RRCrtc *next_crtc = (void*)retval->res.crtcs + sizeof(RRCrtc) * res->ncrtc;
	struct FakeInfo *tcrtc;
	for(tcrtc = crtcs; tcrtc; tcrtc = tcrtc->next) {
		*next_crtc = tcrtc->xid;
		next_crtc++;
	}

	// We copy the outputs that were not overridden and add our fake ones
	retval->res.noutput = 0;
	retval->res.outputs = (void*)retval->res.crtcs + sizeof(RRCrtc) * ncrtc;
	RROutput *next_output = retval->res.outputs;
	for(i=0; i<res->noutput; i++) {
		if(xid_in_list(outputs, res->outputs[i])) {
			struct FakeInfo *toutput;
			for(toutput=outputs; toutput; toutput = toutput->next) {
				if((toutput->xid & ~XID_SPLIT_MASK) == res->outputs[i]) {
					*next_output = toutput->xid;
					next_output++;
					retval->res.noutput++;
				}
			}
		}
		else {
			*next_output = res->outputs[i];
			next_output++;
			retval->res.noutput++;
		}
	}

	// We copy all the original modes and add our fake ones
	retval->res.nmode = nmodes;
	retval->res.modes = (void*)retval->res.outputs + sizeof(RROutput) * noutput;
	memcpy(retval->res.modes, res->modes, res->nmode * sizeof(XRRModeInfo));
	XRRModeInfo *next_mode = (void*)retval->res.modes + res->nmode * (sizeof(XRRModeInfo));
	struct FakeInfo *tmode;
	for(tmode = modes; tmode; tmode = tmode->next) {
		*next_mode = *(XRRModeInfo *)tmode->info;
		next_mode++;
	}
	retval->fake_modes = modes;

	return retval;
}

/*
	Intercept XSetErrorHandler to suppress BadRROutput errors from
	operations on fake output XIDs that bypass our libXrandr interception
	(e.g. raw xcb/Xlib protocol calls from Muffin).

	We wrap XSetErrorHandler so that any handler the app installs is
	stored and called for non-fake errors, while BadRROutput errors
	from RandR are silently suppressed.
*/
static int _randr_error_base = 0;
static XErrorHandler _app_error_handler = NULL;
static XErrorHandler (*_real_XSetErrorHandler)(XErrorHandler) = NULL;

static int _fakexrandr_error_handler(Display *dpy, XErrorEvent *ev) {
	/* RandR BadRROutput = error_base + 1 */
	if(_randr_error_base && ev->error_code == (unsigned char)(_randr_error_base + 1)) {
		return 0;
	}
	if(_app_error_handler) {
		return _app_error_handler(dpy, ev);
	}
	return 0;
}

XErrorHandler XSetErrorHandler(XErrorHandler handler) {
	if(!_real_XSetErrorHandler) {
		_real_XSetErrorHandler = dlsym(RTLD_NEXT, "XSetErrorHandler");
	}
	/* Store the app's handler, but keep our wrapper installed */
	XErrorHandler old = _app_error_handler;
	_app_error_handler = handler;
	_real_XSetErrorHandler(_fakexrandr_error_handler);
	return old;
}

static void _init() __attribute__((constructor));
static void _init() {
	void *xrandr_lib = dlopen(REAL_XRANDR_LIB, RTLD_LAZY | RTLD_GLOBAL);

	/*
		The following macro is defined by the skeleton header. It initializes
		static variables called _XRRfn with references to the real XRRfn
		functions.
	*/
	FUNCTION_POINTER_INITIALIZATIONS;
}

/*
	Bootstrap: get RandR error base and install our error handler.
*/
static void _init_error_handler() __attribute__((constructor(65535)));
static void _init_error_handler() {
	_real_XSetErrorHandler = dlsym(RTLD_NEXT, "XSetErrorHandler");

	/* Try to get RandR error base from the default display */
	Display *dpy = XOpenDisplay(NULL);
	if(dpy) {
		int event_base;
		if(_XRRQueryExtension(dpy, &event_base, &_randr_error_base)) {
			/* Success — _randr_error_base is set */
		}
		XCloseDisplay(dpy);
	}
	/* Install our wrapper as the initial handler */
	if(_real_XSetErrorHandler) {
		_app_error_handler = _real_XSetErrorHandler(_fakexrandr_error_handler);
	}
}

/*
	Overridden library functions to add the fake output
*/

XRRScreenResources *XRRGetScreenResources(Display *dpy, Window window) {
	// Create a screen resources copy augmented with fake outputs & crtcs
	XRRScreenResources *res = _XRRGetScreenResources(dpy, window);
	struct FakeScreenResources *retval = augment_resources(dpy, res);
	return (XRRScreenResources *)retval;
}

void XRRFreeScreenResources(XRRScreenResources *resources) {
	struct FakeScreenResources *res = (void *)resources;

	_XRRFreeScreenResources(res->parent_res);
	free_list(res->fake_crtcs);
	free_list(res->fake_outputs);
	free_list(res->fake_modes);
	Xfree(resources);
}

XRRScreenResources *XRRGetScreenResourcesCurrent(Display *dpy, Window window) {
	XRRScreenResources *res = _XRRGetScreenResourcesCurrent(dpy, window);
	struct FakeScreenResources *retval = augment_resources(dpy, res);
	return (XRRScreenResources *)retval;
}

XRROutputInfo *XRRGetOutputInfo(Display *dpy, XRRScreenResources *resources, RROutput output) {
	struct FakeInfo *fake = xid_in_list(((struct FakeScreenResources *)resources)->fake_outputs, output);
	if(fake) {
		// We have to *clone* this here to mitigate issues due to the Gnome folks misusing the API, see
		// gnome bugzilla #755934
		XRROutputInfo *retval = Xmalloc(sizeof(XRROutputInfo));
		memcpy(retval, fake->info, sizeof(XRROutputInfo));
		return retval;
	}

	XRROutputInfo *retval = _XRRGetOutputInfo(dpy, resources, output & ~XID_SPLIT_MASK);
	return retval;
}

void XRRFreeOutputInfo(XRROutputInfo *outputInfo) {
	// Note: If I can ever remove the cloning of the XRROutputInfo above, this won't work anymore!
	_XRRFreeOutputInfo(outputInfo);
}

XRRCrtcInfo *XRRGetCrtcInfo(Display *dpy, XRRScreenResources *resources, RRCrtc crtc) {
	struct FakeInfo *fake = xid_in_list(((struct FakeScreenResources *)resources)->fake_crtcs, crtc);
	if(fake) {
		// We have to *clone* this here to mitigate issues due to the Gnome folks misusing the API, see
		// gnome bugzilla #755934
		XRRCrtcInfo *retval = Xmalloc(sizeof(XRRCrtcInfo));
		memcpy(retval, fake->info, sizeof(XRRCrtcInfo));
		return retval;
	}

	XRRCrtcInfo *retval = _XRRGetCrtcInfo(dpy, resources, crtc & ~XID_SPLIT_MASK);
	return retval;
}

void XRRFreeCrtcInfo(XRRCrtcInfo *crtcInfo) {
	// Note: If I can ever remove the cloning of the XRROutputInfo above, this won't work anymore!
	_XRRFreeCrtcInfo(crtcInfo);
}

void XRRSetCrtcTransform(Display *dpy, RRCrtc crtc, XTransform *transform, const char *filter, XFixed *params, int nparams) {
	if(crtc & XID_SPLIT_MASK) return;
	_XRRSetCrtcTransform(dpy, crtc, transform, filter, params, nparams);
}

/*
	Override output property functions to no-op on fake outputs.
	Muffin tries to set properties (e.g. backlight) on our virtual
	outputs, but the X server rejects these because the XIDs don't
	exist as real outputs. Instead of forwarding with a stripped XID,
	silently ignore operations on fake outputs.
*/
void XRRChangeOutputProperty(Display *dpy, RROutput output, Atom property, Atom type, int format, int mode, const unsigned char *data, int nelements) {
	if(output & XID_SPLIT_MASK) return;
	_XRRChangeOutputProperty(dpy, output, property, type, format, mode, data, nelements);
}

void XRRDeleteOutputProperty(Display *dpy, RROutput output, Atom property) {
	if(output & XID_SPLIT_MASK) return;
	_XRRDeleteOutputProperty(dpy, output, property);
}

void XRRConfigureOutputProperty(Display *dpy, RROutput output, Atom property, int pending, int range, int num_values, long *values) {
	if(output & XID_SPLIT_MASK) return;
	_XRRConfigureOutputProperty(dpy, output, property, pending, range, num_values, values);
}

Atom *XRRListOutputProperties(Display *dpy, RROutput output, int *nprop) {
	if(output & XID_SPLIT_MASK) { *nprop = 0; return NULL; }
	return _XRRListOutputProperties(dpy, output, nprop);
}

int XRRGetOutputProperty(Display *dpy, RROutput output, Atom property, long offset, long length, int _delete, int pending, Atom req_type, Atom *actual_type, int *actual_format, unsigned long *nitems, unsigned long *bytes_after, unsigned char **prop) {
	if(output & XID_SPLIT_MASK) {
		*actual_type = None; *actual_format = 0; *nitems = 0; *bytes_after = 0; *prop = NULL;
		return 1;
	}
	return _XRRGetOutputProperty(dpy, output, property, offset, length, _delete, pending, req_type, actual_type, actual_format, nitems, bytes_after, prop);
}

XRRPropertyInfo *XRRQueryOutputProperty(Display *dpy, RROutput output, Atom property) {
	if(output & XID_SPLIT_MASK) return NULL;
	return _XRRQueryOutputProperty(dpy, output, property);
}

int XRRSetCrtcConfig(Display *dpy, XRRScreenResources *resources, RRCrtc crtc, Time timestamp, int x, int y, RRMode mode, Rotation rotation, RROutput *outputs, int noutputs) {
	if(crtc & XID_SPLIT_MASK) {
		/* Update the fake CRTC info so readback matches what was requested */
		struct FakeInfo *fake = xid_in_list(((struct FakeScreenResources *)resources)->fake_crtcs, crtc);
		if(fake) {
			XRRCrtcInfo *info = fake->info;
			info->x = x;
			info->y = y;
			info->mode = mode;
			info->rotation = rotation;
		}
		return RRSetConfigSuccess;
	}
	int i;
	for(i=0; i<noutputs; i++) {
		if(outputs[i] & XID_SPLIT_MASK) {
			return RRSetConfigSuccess;
		}
	}

	return _XRRSetCrtcConfig(dpy, resources, crtc, timestamp, x, y, mode, rotation, outputs, noutputs);
}

/*
	XRRGetMonitors override

	Muffin (Cinnamon's WM) uses XRRGetMonitors() (XRandR 1.5) to discover
	monitors. Without this override, it sees only physical monitors and
	ignores our virtual splits, causing position reverts on SIGCONT resume.
*/

struct SplitRegion { unsigned int x, y, w, h; };

static const char *_collect_leaf_regions(const char *config,
	unsigned int x, unsigned int y, unsigned int w, unsigned int h,
	struct SplitRegion *regions, int *count, int max_count) {

	if(config[0] != 'N' && config[0] != 'H' && config[0] != 'V') {
		return NULL;
	}

	if(config[0] == 'N') {
		if(*count < max_count) {
			regions[*count].x = x;
			regions[*count].y = y;
			regions[*count].w = w;
			regions[*count].h = h;
			(*count)++;
		}
		return config + 1;
	}

	unsigned int split_pos = *(unsigned int *)&config[1];
	if(config[0] == 'H') {
		if(split_pos == 0) split_pos = h / 2;
		const char *next = _collect_leaf_regions(config + 1 + 4, x, y, w, split_pos, regions, count, max_count);
		if(!next) return NULL;
		return _collect_leaf_regions(next, x, y + split_pos, w, h - split_pos, regions, count, max_count);
	}
	else {
		if(split_pos == 0) split_pos = w / 2;
		const char *next = _collect_leaf_regions(config + 1 + 4, x, y, split_pos, h, regions, count, max_count);
		if(!next) return NULL;
		return _collect_leaf_regions(next, x + split_pos, y, w - split_pos, h, regions, count, max_count);
	}
}

/*
	Look up a config entry by output name. Returns the number of leaf
	split regions, or 0 if no config matches. parent_output_xid is the
	real X output XID for this output (used to build fake XIDs).
*/
static int _get_split_regions_for_output(Display *dpy, const char *output_name,
	RROutput output_xid, struct SplitRegion *regions, int max_count,
	unsigned int *out_config_w, unsigned int *out_config_h) {

	if(!config_file) return 0;

	char output_edid[768];
	get_output_edid(dpy, output_xid, output_edid);

	char *config;
	for(config = config_file + CONFIG_DATA_OFFSET; (int)(config - config_file) <= (int)config_file_size; ) {
		unsigned int size = *(unsigned int *)config;
		char *name = &config[4];
		char *edid = &config[4 + 128];
		unsigned int width = *(unsigned int *)&config[4 + 128 + 768];
		unsigned int height = *(unsigned int *)&config[4 + 128 + 768 + 4];

		int name_match = (output_name && strncmp(name, output_name, 128) == 0);
		int edid_match = (strncmp(edid, output_edid, 768) == 0);

		if(name_match || edid_match) {
			char *tree_start = config + 4 + 128 + 768 + 4 + 4 + 4 + 4;

			/* Use stored config dimensions (0 = use actual) */
			*out_config_w = width;
			*out_config_h = height;

			int count = 0;
			_collect_leaf_regions(tree_start, 0, 0,
				width ? width : 9999, height ? height : 9999,
				regions, &count, max_count);
			return count;
		}

		config += 4 + size;
	}

	return 0;
}

XRRMonitorInfo *XRRGetMonitors(Display *dpy, Window window, int get_active, int *nmonitors) {
	int orig_count = 0;
	XRRMonitorInfo *orig = _XRRGetMonitors(dpy, window, get_active, &orig_count);

	if(!orig || orig_count <= 0) {
		if(nmonitors) *nmonitors = orig_count;
		return orig;
	}

	if(open_configuration()) {
		/* No config — pass through */
		if(nmonitors) *nmonitors = orig_count;
		return orig;
	}

	/* We need real screen resources to look up output XIDs and info */
	XRRScreenResources *res = _XRRGetScreenResourcesCurrent(dpy, window);
	if(!res) {
		if(nmonitors) *nmonitors = orig_count;
		return orig;
	}

	#define MAX_SPLITS 16
	struct SplitRegion regions[MAX_SPLITS];

	/*
		Pass 1: count how many monitors we'll have in the result,
		and how many total outputs we need.
	*/
	int total_monitors = 0;
	int total_outputs = 0;

	for(int i = 0; i < orig_count; i++) {
		char *atom_name = XGetAtomName(dpy, orig[i].name);
		if(!atom_name) {
			total_monitors++;
			total_outputs += orig[i].noutput;
			continue;
		}

		/* Check if this is a setmonitor VM (non-automatic, name contains ~) */
		if(!orig[i].automatic && strchr(atom_name, '~')) {
			/* Strip the ~N suffix to get the base output name */
			char base_name[128];
			strncpy(base_name, atom_name, sizeof(base_name) - 1);
			base_name[sizeof(base_name) - 1] = '\0';
			char *tilde = strchr(base_name, '~');
			if(tilde) *tilde = '\0';

			/* Check if this base name has a split config */
			int has_config = 0;
			for(int j = 0; j < res->noutput; j++) {
				XRROutputInfo *oi = _XRRGetOutputInfo(dpy, res, res->outputs[j]);
				if(oi) {
					if(strcmp(oi->name, base_name) == 0) {
						unsigned int cw, ch;
						int n = _get_split_regions_for_output(dpy, base_name,
							res->outputs[j], regions, MAX_SPLITS, &cw, &ch);
						if(n > 0) has_config = 1;
					}
					_XRRFreeOutputInfo(oi);
					if(has_config) break;
				}
			}

			if(has_config) {
				/* Skip this setmonitor VM — we'll replace with our splits */
				XFree(atom_name);
				continue;
			}
		}

		/* Check if this is an automatic monitor whose output matches a split config */
		if(orig[i].automatic && orig[i].noutput > 0) {
			/* Find the output name for this monitor's first output */
			RROutput mon_output = orig[i].outputs[0];
			XRROutputInfo *oi = _XRRGetOutputInfo(dpy, res, mon_output);
			if(oi && oi->name) {
				unsigned int cw, ch;
				int n = _get_split_regions_for_output(dpy, oi->name, mon_output,
					regions, MAX_SPLITS, &cw, &ch);
				if(n > 0) {
					/* Verify dimensions match (0 in config = match anything) */
					XRRCrtcInfo *ci = oi->crtc ? _XRRGetCrtcInfo(dpy, res, oi->crtc) : NULL;
					int dims_match = 0;
					if(ci) {
						dims_match = (!cw || ci->width == cw) && (!ch || ci->height == ch);
						_XRRFreeCrtcInfo(ci);
					}
					if(dims_match) {
						total_monitors += n;
						total_outputs += n; /* one output per virtual monitor */
						_XRRFreeOutputInfo(oi);
						XFree(atom_name);
						continue;
					}
				}
			}
			if(oi) _XRRFreeOutputInfo(oi);
		}

		/* Non-split monitor: keep as-is */
		total_monitors++;
		total_outputs += orig[i].noutput;
		XFree(atom_name);
	}

	/*
		Pass 2: build the result array.
		Allocate XRRMonitorInfo[] + RROutput[] in a single Xmalloc block.
	*/
	size_t info_size = total_monitors * sizeof(XRRMonitorInfo);
	size_t outputs_size = total_outputs * sizeof(RROutput);
	XRRMonitorInfo *result = Xmalloc(info_size + outputs_size);
	if(!result) {
		_XRRFreeScreenResources(res);
		if(nmonitors) *nmonitors = orig_count;
		return orig;
	}

	RROutput *output_pool = (RROutput *)((char *)result + info_size);
	int out_idx = 0;
	int out_output_idx = 0;

	for(int i = 0; i < orig_count; i++) {
		char *atom_name = XGetAtomName(dpy, orig[i].name);
		if(!atom_name) {
			result[out_idx] = orig[i];
			result[out_idx].outputs = &output_pool[out_output_idx];
			memcpy(result[out_idx].outputs, orig[i].outputs, orig[i].noutput * sizeof(RROutput));
			out_output_idx += orig[i].noutput;
			out_idx++;
			continue;
		}

		/* Check if this is a setmonitor VM to skip */
		if(!orig[i].automatic && strchr(atom_name, '~')) {
			char base_name[128];
			strncpy(base_name, atom_name, sizeof(base_name) - 1);
			base_name[sizeof(base_name) - 1] = '\0';
			char *tilde = strchr(base_name, '~');
			if(tilde) *tilde = '\0';

			int has_config = 0;
			for(int j = 0; j < res->noutput; j++) {
				XRROutputInfo *oi = _XRRGetOutputInfo(dpy, res, res->outputs[j]);
				if(oi) {
					if(strcmp(oi->name, base_name) == 0) {
						unsigned int cw, ch;
						int n = _get_split_regions_for_output(dpy, base_name,
							res->outputs[j], regions, MAX_SPLITS, &cw, &ch);
						if(n > 0) has_config = 1;
					}
					_XRRFreeOutputInfo(oi);
					if(has_config) break;
				}
			}

			if(has_config) {
				XFree(atom_name);
				continue;
			}
		}

		/* Check if this is an automatic monitor to split */
		if(orig[i].automatic && orig[i].noutput > 0) {
			RROutput mon_output = orig[i].outputs[0];
			XRROutputInfo *oi = _XRRGetOutputInfo(dpy, res, mon_output);
			if(oi && oi->name) {
				unsigned int cw, ch;
				int n = _get_split_regions_for_output(dpy, oi->name, mon_output,
					regions, MAX_SPLITS, &cw, &ch);
				if(n > 0) {
					XRRCrtcInfo *ci = oi->crtc ? _XRRGetCrtcInfo(dpy, res, oi->crtc) : NULL;
					int dims_match = 0;
					if(ci) {
						dims_match = (!cw || ci->width == cw) && (!ch || ci->height == ch);
					}
					if(dims_match) {
						/* Emit virtual monitors for each split region */
						for(int s = 0; s < n; s++) {
							char vname[128];
							/* 1-indexed to match fakexrandr naming convention */
							snprintf(vname, sizeof(vname), "%s~%d", oi->name, s + 1);

							result[out_idx].name = XInternAtom(dpy, vname, False);
							result[out_idx].automatic = False;
							result[out_idx].primary = (s == 0) ? orig[i].primary : False;
							result[out_idx].x = ci->x + regions[s].x;
							result[out_idx].y = ci->y + regions[s].y;
							result[out_idx].width = regions[s].w;
							result[out_idx].height = regions[s].h;
							/* Proportional physical mm dimensions */
							result[out_idx].mwidth = orig[i].mwidth * regions[s].w / ci->width;
							result[out_idx].mheight = orig[i].mheight * regions[s].h / ci->height;
							result[out_idx].noutput = 1;
							result[out_idx].outputs = &output_pool[out_output_idx];
							/* Fake XID matching _config_foreach_split convention */
							output_pool[out_output_idx] = (mon_output & ~XID_SPLIT_MASK) | ((s + 1) << XID_SPLIT_SHIFT);
							out_output_idx++;
							out_idx++;
						}
						if(ci) _XRRFreeCrtcInfo(ci);
						_XRRFreeOutputInfo(oi);
						XFree(atom_name);
						continue;
					}
					if(ci) _XRRFreeCrtcInfo(ci);
				}
			}
			if(oi) _XRRFreeOutputInfo(oi);
		}

		/* Non-split monitor: copy as-is */
		result[out_idx] = orig[i];
		result[out_idx].outputs = &output_pool[out_output_idx];
		memcpy(result[out_idx].outputs, orig[i].outputs, orig[i].noutput * sizeof(RROutput));
		out_output_idx += orig[i].noutput;
		out_idx++;
		XFree(atom_name);
	}

	_XRRFreeScreenResources(res);
	_XRRFreeMonitors(orig);

	if(nmonitors) *nmonitors = out_idx;
	return result;
}

/*
	Fake Xinerama

	This is little overhead with all the work we already did above..
*/
#ifndef NO_FAKE_XINERAMA
Bool XineramaQueryExtension(Display *dpy, int *event_base, int *error_base) {
	return xTrue;
}
Bool XineramaIsActive(Display *dpy) {
	return xTrue;
}
Status XineramaQueryVersion(Display *dpy, int *major, int *minor) {
	*major = 1;
	*minor = 0;
	return xTrue;
}

XineramaScreenInfo* XineramaQueryScreens(Display *dpy, int *number) {
	XRRScreenResources *res = XRRGetScreenResources(dpy, XDefaultRootWindow(dpy));

	XineramaScreenInfo *retval = Xmalloc(res->noutput * sizeof(XineramaScreenInfo));
	int i;
	*number = 0;
	for(i=0; i<res->noutput; i++) {
		XRROutputInfo *output = XRRGetOutputInfo(dpy, res, res->outputs[i]);
		if(output->crtc) {
			XRRCrtcInfo *crtc = XRRGetCrtcInfo(dpy, res, output->crtc);

			retval[*number].screen_number = *number;
			retval[*number].x_org = crtc->x;
			retval[*number].y_org = crtc->y;
			retval[*number].width = crtc->width;
			retval[*number].height = crtc->height;
			(*number)++;
			XRRFreeCrtcInfo(crtc);
		}

		XRRFreeOutputInfo(output);
	}

	XRRFreeScreenResources(res);

    return retval;
}
#endif

/*
	Intercept xcb-randr calls that Muffin makes directly via libxcb-randr,
	bypassing our libXrandr interception. Operations on fake CRTCs/outputs
	(those with XID_SPLIT_MASK bits set) are silently no-op'd.
*/

static xcb_void_cookie_t _fake_void_cookie = { .sequence = 0 };
static xcb_randr_set_crtc_config_cookie_t _fake_crtc_cookie = { .sequence = 0 };

xcb_void_cookie_t
xcb_randr_set_crtc_transform_checked(xcb_connection_t *c, xcb_randr_crtc_t crtc,
	xcb_render_transform_t transform, uint16_t filter_len, const char *filter_name,
	uint32_t filter_params_len, const xcb_render_fixed_t *filter_params)
{
	static xcb_void_cookie_t (*_real)(xcb_connection_t *, xcb_randr_crtc_t,
		xcb_render_transform_t, uint16_t, const char *, uint32_t, const xcb_render_fixed_t *) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_set_crtc_transform_checked");
	if(crtc & XID_SPLIT_MASK) return _fake_void_cookie;
	return _real(c, crtc, transform, filter_len, filter_name, filter_params_len, filter_params);
}

xcb_void_cookie_t
xcb_randr_set_crtc_transform(xcb_connection_t *c, xcb_randr_crtc_t crtc,
	xcb_render_transform_t transform, uint16_t filter_len, const char *filter_name,
	uint32_t filter_params_len, const xcb_render_fixed_t *filter_params)
{
	static xcb_void_cookie_t (*_real)(xcb_connection_t *, xcb_randr_crtc_t,
		xcb_render_transform_t, uint16_t, const char *, uint32_t, const xcb_render_fixed_t *) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_set_crtc_transform");
	if(crtc & XID_SPLIT_MASK) return _fake_void_cookie;
	return _real(c, crtc, transform, filter_len, filter_name, filter_params_len, filter_params);
}

xcb_randr_set_crtc_config_cookie_t
xcb_randr_set_crtc_config_checked(xcb_connection_t *c, xcb_randr_crtc_t crtc,
	xcb_timestamp_t timestamp, xcb_timestamp_t config_timestamp,
	int16_t x, int16_t y, xcb_randr_mode_t mode, uint16_t rotation,
	uint32_t outputs_len, const xcb_randr_output_t *outputs)
{
	static xcb_randr_set_crtc_config_cookie_t (*_real)(xcb_connection_t *, xcb_randr_crtc_t,
		xcb_timestamp_t, xcb_timestamp_t, int16_t, int16_t, xcb_randr_mode_t,
		uint16_t, uint32_t, const xcb_randr_output_t *) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_set_crtc_config_checked");
	if(crtc & XID_SPLIT_MASK) return _fake_crtc_cookie;
	uint32_t i;
	for(i = 0; i < outputs_len; i++) {
		if(outputs[i] & XID_SPLIT_MASK) return _fake_crtc_cookie;
	}
	return _real(c, crtc, timestamp, config_timestamp, x, y, mode, rotation, outputs_len, outputs);
}

xcb_randr_set_crtc_config_cookie_t
xcb_randr_set_crtc_config(xcb_connection_t *c, xcb_randr_crtc_t crtc,
	xcb_timestamp_t timestamp, xcb_timestamp_t config_timestamp,
	int16_t x, int16_t y, xcb_randr_mode_t mode, uint16_t rotation,
	uint32_t outputs_len, const xcb_randr_output_t *outputs)
{
	static xcb_randr_set_crtc_config_cookie_t (*_real)(xcb_connection_t *, xcb_randr_crtc_t,
		xcb_timestamp_t, xcb_timestamp_t, int16_t, int16_t, xcb_randr_mode_t,
		uint16_t, uint32_t, const xcb_randr_output_t *) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_set_crtc_config");
	if(crtc & XID_SPLIT_MASK) return _fake_crtc_cookie;
	uint32_t i;
	for(i = 0; i < outputs_len; i++) {
		if(outputs[i] & XID_SPLIT_MASK) return _fake_crtc_cookie;
	}
	return _real(c, crtc, timestamp, config_timestamp, x, y, mode, rotation, outputs_len, outputs);
}

xcb_randr_set_crtc_config_reply_t *
xcb_randr_set_crtc_config_reply(xcb_connection_t *c,
	xcb_randr_set_crtc_config_cookie_t cookie, xcb_generic_error_t **e)
{
	static xcb_randr_set_crtc_config_reply_t *(*_real)(xcb_connection_t *,
		xcb_randr_set_crtc_config_cookie_t, xcb_generic_error_t **) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_set_crtc_config_reply");

	/* If this is a fake cookie (from our no-op), return a success reply */
	if(cookie.sequence == 0) {
		xcb_randr_set_crtc_config_reply_t *reply = calloc(1, sizeof(*reply));
		reply->response_type = 1; /* XCB_REPLY */
		reply->status = 0; /* RRSetConfigSuccess */
		if(e) *e = NULL;
		return reply;
	}
	return _real(c, cookie, e);
}

xcb_void_cookie_t
xcb_randr_change_output_property_checked(xcb_connection_t *c, xcb_randr_output_t output,
	xcb_atom_t property, xcb_atom_t type, uint8_t format, uint8_t mode,
	uint32_t num_units, const void *data)
{
	static xcb_void_cookie_t (*_real)(xcb_connection_t *, xcb_randr_output_t,
		xcb_atom_t, xcb_atom_t, uint8_t, uint8_t, uint32_t, const void *) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_change_output_property_checked");
	if(output & XID_SPLIT_MASK) return _fake_void_cookie;
	return _real(c, output, property, type, format, mode, num_units, data);
}

xcb_void_cookie_t
xcb_randr_change_output_property(xcb_connection_t *c, xcb_randr_output_t output,
	xcb_atom_t property, xcb_atom_t type, uint8_t format, uint8_t mode,
	uint32_t num_units, const void *data)
{
	static xcb_void_cookie_t (*_real)(xcb_connection_t *, xcb_randr_output_t,
		xcb_atom_t, xcb_atom_t, uint8_t, uint8_t, uint32_t, const void *) = NULL;
	if(!_real) _real = dlsym(RTLD_NEXT, "xcb_randr_change_output_property");
	if(output & XID_SPLIT_MASK) return _fake_void_cookie;
	return _real(c, output, property, type, format, mode, num_units, data);
}
